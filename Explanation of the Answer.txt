PracticeA
Sは1~100文字で長さが指定されません。
character(100)で変数Sを用意して、100文字分格納できる変数を用意しましょう。

ABC086A
aとbの積を2で割ったあまりが0か1かによって、偶数か奇数を判定します。
あまりの計算はmod関数で行います。

ABC081A
s1,s2,s3の入力がスペースで区切られていないため、そのまま読み込むと３桁の数として認識されてしまいます。
read文に書式を記載し、１文字区切りで値をs1,s2,s3へ読み込みます。

ABC081B
正の整数Aの要素数は入力Nによって決まるため、Aは動的割り付け可能な配列として宣言します。
Aの全ての要素に対して２で割ることができるか確かめる必要がありますが、all関数を用いてまとめて判定を行うことができます。
また、Aを２で割る際にも、A=A/2とすることで全ての要素に対してまとめて処理を行うことができます。

https://qiita.com/implicit_none/items/1156a3b091d9556e310d

ABC087B
A,B,Cを0枚から全部使う組み合わせを全て試して、X円になる組み合わせを数えます。
3重のdo loopになりますが、A,B,Cは最大で50と少ないため、実行時間超過は発生しません。


ABC083B
整数i を 各桁に分割する部分をsubroutineで実装しています。

ABC088B
Aを昇順にソートし、Alice→Bob→Alice...の順でカードを割り当てます。
ゲームの参加者は２名で交互にカードを取得するため、Aliceは奇数の時にカードを取得し、Bobは偶数の時にカードを取得します。


ABC085B
dを昇順にソートして、順番に鏡餅として積み重ねを行います。
ただし積み重ねる餅は真下の餅より小さい必要があるため、最上段の餅のサイズを保持しておき、サイズを比較しながら積み上げするか判定します。

ABC085C 
10000円札、5000円札の組み合わせを総当たりで調べます。
なお、1000円札の枚数は、総当たりで調べる必要はありません。
10000円札、5000円札の枚数が定まる時、合計枚数Nから引くことで1000円札は求められます。

ABC049C
dream dreamer erase eraser は内容が部分的に一致しているため、先頭から文字列の判定を行う場合は、文字列の区切る位置の見極めがつきません。
この問題を回避するために、文字列の末尾から順に単語として区切っていきます。

ABC086C
1単位時間に移動できる移動量は、x,y のいずれかに１マスです。
現在地点から目的地までの移動距離が移動時間を越える場合は、移動距離が足りなくなるため旅行プランは実行不可能です。
移動距離と移動時間の偶奇が一致する場合に、旅行プランは実行可能となります。
